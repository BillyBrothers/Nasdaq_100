R = asset_returns_xts,
portfolio = min_var_portfolio,
# This defaults to the "quadprog" solver
optimize_method = "ROI",
solver = 'Quadprog',
# Return additional information on the path or portfolios searched
trace = TRUE
)
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'ROI',
solver = 'quadprog',
trace = TRUE
)
install.packages("ROI")
install.packages("ROI.plugin.quadprog")
install.packages("ROI")
library(ROI)
library(ROI.plugin.quadprog
library(tidyverse)
# install.packages("ROI")
# install.packages("ROI.plugin.quadprog")
library(ROI)
library(ROI.plugin.quadprog)
library(tidyverse)
library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(timetk)
library(tibbletime)
library(xts)
library(zoo)
library(tidyquant)
#install.packages("quadprog")
library(quadprog)
# install.packages("ROI")
# install.packages("ROI.plugin.quadprog")
library(ROI)
library(ROI.plugin.quadprog)
library(tidyverse)
library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(timetk)
library(tibbletime)
library(xts)
library(zoo)
library(tidyquant)
#install.packages("quadprog")
library(quadprog)
symbols <- c("AAPL", "PFE", "JPM", "XOM", "AMT", "KO", "TGT", "BA", "NEM", "EXC", "DIS")
#I'm using getSymbols from quantmod library because it returns a time series object in xts form.
prices <- getSymbols(
Symbols = symbols,
src = 'yahoo',
auto.assign = TRUE,
warnings = FALSE
) |>
# get unpacks our financial price data (Open, High, Low, Close, Volume, Adjusted). Ad returns ONLY the daily adjusted price (accounts for any dividends paid, corporate actions, or adjustments that would affect the price of the stock. Map returns each individual stock data into a list.
map(.f = ~Ad(get(x = .))) |>
#reduce applies a function to each element of the list?
reduce(.f = merge) |>
# I needed to set the ticker symbol to the name of the columns. I found this nifty way of doing it since colnames(x=prices) <- value didn't work and I don't know why. Apparently this is prefix form. (Ex. AAPL.Adjusted is now AAPL)
`colnames<-` (value=symbols)
# Keep only the last adjusted price of each month because we are focused on a long-term investment horizon, plus daily price flucuations cause too much noise and make it harder to identify long term trends.
# to.monthly() function is apart of xts library and is used to convert daily price data to monthly. We have set the adjusted close price to the last of each month, dropped the time, and set OHLC = False which means no "OPEN, HIGH, LOW, CLOSE" values.
monthly_adjusted_returns <- to.monthly(
x = prices,
drop.time = TRUE,
indexAt = 'lastof',
OHLC = FALSE
) |>
#We calculating simple returns  with the return.calculate function from PerformanceAnalytics library
Return.calculate(method = 'discrete') |>
na.omit()
monthly_adjusted_returns
#Creates a portfolio object using portfolio.spec function, which is a function from of PortfolioAnalytics
# returns a list.
Minimum_Variance_Portfolio <- portfolio.spec(assets = symbols)
Minimum_Variance_Portfolio
# Add Full Investment Constraint (weight sum constraint - weights must sum to 1)
Minimum_Variance_Portfolio <- add.constraint(
portfolio = Minimum_Variance_Portfolio,
type = 'full_investment'
)
Minimum_Variance_Portfolio
# Add Box Constraint(weights have minimum and maximum values)
Minimum_Variance_Portfolio <- add.constraint(
portfolio = Minimum_Variance_Portfolio,
type = 'box',
min = 0.05,
max = .6
)
Minimum_Variance_Portfolio
# Add Objective to minimize risk (we are creating a minimization portfolio)
Minimum_Variance_Portfolio <- add.objective(
portfolio = Minimum_Variance_Portfolio,
type = 'risk',
name = 'var'
)
Minimum_Variance_Portfolio
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'ROI',
solver = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
Main_Variance_Portfolio$weights
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'ROI',
solver = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'ROI',
solver = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
weights <- pluck(.x = main_expected_return_portfolio,
'weights',
)
# install.packages("ROI")
# install.packages("ROI.plugin.quadprog")
#install.packages("Rglpk")
# install.packages("ROI.plugin.glpk")
library(Rglpk)
library(ROI.plugin.glpk)
library(ROI)
library(ROI.plugin.quadprog)
library(tidyverse)
library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(timetk)
library(tibbletime)
library(xts)
library(zoo)
library(tidyquant)
#install.packages("quadprog")
library(quadprog)
# install.packages("ROI")
# install.packages("ROI.plugin.quadprog")
#install.packages("Rglpk")
# install.packages("ROI.plugin.glpk")
library(Rglpk)
library(ROI.plugin.glpk)
library(ROI)
library(ROI.plugin.quadprog)
library(tidyverse)
library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(timetk)
library(tibbletime)
library(xts)
library(zoo)
library(tidyquant)
#install.packages("quadprog")
library(quadprog)
symbols <- c("AAPL", "PFE", "JPM", "XOM", "AMT", "KO", "TGT", "BA", "NEM", "EXC", "DIS")
#I'm using getSymbols from quantmod library because it returns a time series object in xts form.
prices <- getSymbols(
Symbols = symbols,
src = 'yahoo',
auto.assign = TRUE,
warnings = FALSE
) |>
# get() unpacks our financial price data (Open, High, Low, Close, Volume, Adjusted). Ad returns ONLY the daily adjusted price (accounts for any dividends paid, corporate actions, or adjustments that would effect the price of the stock. Map returns each individual stock data into a list.
map(.f = ~Ad(get(x = .))) |>
#reduce applies a function to each element of the list?
reduce(.f = merge) |>
# I needed to set the ticker symbol to the name of the columns. I found this nifty way of doing it since colnames(x=prices) <- value didn't work and I don't know why. Apparently this is prefix form. (Ex. AAPL.Adjusted is now AAPL)
`colnames<-` (value=symbols)
prices
# Keep only the last adjusted price of each month because we are focused on a long-term investment horizon, plus daily price flucuations cause too much noise can make it harder to identify long term trends.
# to.monthly() function is apart of xts library and is used to convert daily price data to monthly. We have set the adjusted close price to the last of each month, dropped the time, and set OHLC = False which means no "OPEN, HIGH, LOW, CLOSE" values.
monthly_adjusted_returns <- to.monthly(
x = prices,
drop.time = TRUE,
indexAt = 'lastof',
OHLC = FALSE
) |>
#We calculating simple returns  with the return.calculate function from PerformanceAnalytics library
Return.calculate(method = 'discrete') |>
na.omit()
monthly_adjusted_returns
#Creates a portfolio object using portfolio.spec function, which is a function from of PortfolioAnalytics
# returns a list.
Minimum_Variance_Portfolio <- portfolio.spec(assets = symbols)
Minimum_Variance_Portfolio
# Add Full Investment Constraint (weight sum constraint - weights must sum to 1 - prevents overleveraging and ensures diversification)
Minimum_Variance_Portfolio <- add.constraint(
portfolio = Minimum_Variance_Portfolio,
type = 'full_investment'
)
Minimum_Variance_Portfolio
# Add Box Constraint(weights have minimum and maximum values - limits the range of weights in the portfolio. Limits over/under leveraging for assets. Promotes diversification)
Minimum_Variance_Portfolio <- add.constraint(
portfolio = Minimum_Variance_Portfolio,
type = 'box',
min = 0.1,
max = .6
)
Minimum_Variance_Portfolio
# Add Objective to minimize risk (we are creating a minimization portfolio)
Minimum_Variance_Portfolio <- add.objective(
portfolio = Minimum_Variance_Portfolio,
type = 'risk',
name = 'var'
)
Minimum_Variance_Portfolio
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
#Creates a portfolio object using portfolio.spec function, which is a function from of PortfolioAnalytics
# returns a list.
maximum_expected_return_portfolio <- portfolio.spec(
assets = symbols
)
maximum_expected_return_portfolio
# Add Full Investment Constraint (weight sum constraint)
maximum_expected_return_portfolio <- add.constraint(
portfolio = maximum_expected_return_portfolio,
# similar to full_investment, expect you can modify the parameters for 'min_sum' and 'max_sum' to ease up constraints for calculating maximal returns
type = 'weight_sum',
min_sum = 0.99,
max_sum = 1.01,
enabled = TRUE
)
maximum_expected_return_portfolio
# Adding box constraint
maximum_expected_return_portfolio <- add.constraint(
portfolio = maximum_expected_return_portfolio,
type = 'box',
min = 0.1,
max = 0.6
)
maximum_expected_return_portfolio
# Add objective function - we are implementing a linear function to calculate the maximal expected returns
maximum_expected_return_portfolio <- add.objective(
portfolio = maximum_expected_return_portfolio,
type = 'return',
# name of function used to calculate the returns (we're just naming the type = 'return' parameter.:
name = 'mean'
)
maximum_expected_return_portfolio
# Optimize the portfolio
main_expected_return_portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = maximum_expected_return_portfolio,
# used for linear functions with linear constraints
optimize_method = "Rglpk",
trace = TRUE
)
main_expected_return_portfolio
class(main_expected_return_portfolio$objective_measures$mean)
#average annual return you can expect to earn.
(1+main_expected_return_portfolio$objective_measures$mean)^12-1
weights <- pluck(.x = main_expected_return_portfolio,
'weights',
)
weights <- pluck(.x = main_expected_return_portfolio,
'weights',
)
weights
weights <- pluck(.x = main_expected_return_portfolio,
'weights',
)
tibble(weights, symbols)
weights <- pluck(main_expected_return_portfolio,
'weights',
)
tibble(weights, symbols)
#Creates a portfolio object using portfolio.spec function, which is a function from of PortfolioAnalytics
# returns a list.
maximum_expected_return_portfolio <- portfolio.spec(
assets = symbols
)
maximum_expected_return_portfolio
# Add weight_sum Constraint (weight sum constraint)
maximum_expected_return_portfolio <- add.constraint(
portfolio = maximum_expected_return_portfolio,
# similar to full_investment, expect you can modify the parameters for 'min_sum' and 'max_sum' to ease up constraints for calculating maximal returns
type = 'weight_sum',
min_sum = 0.99,
max_sum = 1.01,
enabled = TRUE
)
maximum_expected_return_portfolio
# Adding box constraint
maximum_expected_return_portfolio <- add.constraint(
portfolio = maximum_expected_return_portfolio,
type = 'box',
min = 0.05,
max = 0.6
)
maximum_expected_return_portfolio
# Add objective function - we are implementing a linear function to calculate the maximal expected returns
maximum_expected_return_portfolio <- add.objective(
portfolio = maximum_expected_return_portfolio,
type = 'return',
# name of function used to calculate the returns (we're just naming the type = 'return' parameter.:
name = 'mean'
)
maximum_expected_return_portfolio
# Optimize the portfolio
main_expected_return_portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = maximum_expected_return_portfolio,
# used for linear functions with linear constraints
optimize_method = "Rglpk",
trace = TRUE
)
main_expected_return_portfolio
class(main_expected_return_portfolio$objective_measures$mean)
#average annual return you can expect to earn.
(1+main_expected_return_portfolio$objective_measures$mean)^12-1
weights <- pluck(main_expected_return_portfolio,
'weights',
)
tibble(weights, symbols)
#check for sum_constaint
tibble(weights, symbols) |>
summarize(total_weight = sum(weights))
# install.packages("ROI")
# install.packages("ROI.plugin.quadprog")
#install.packages("Rglpk")
# install.packages("ROI.plugin.glpk")
library(Rglpk)
library(ROI.plugin.glpk)
library(ROI)
library(ROI.plugin.quadprog)
library(tidyverse)
library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(timetk)
library(tibbletime)
library(xts)
library(zoo)
library(tidyquant)
#install.packages("quadprog")
library(quadprog)
symbols <- c("AAPL", "PFE", "JPM", "XOM", "AMT", "KO", "TGT", "BA", "NEM", "EXC", "DIS")
#I'm using getSymbols from quantmod library because it returns a time series object in xts form.
prices <- getSymbols(
Symbols = symbols,
src = 'yahoo',
auto.assign = TRUE,
warnings = FALSE
) |>
# get() unpacks our financial price data (Open, High, Low, Close, Volume, Adjusted). Ad returns ONLY the daily adjusted price (accounts for any dividends paid, corporate actions, or adjustments that would effect the price of the stock. Map returns each individual stock data into a list.
map(.f = ~Ad(get(x = .))) |>
#reduce applies a function to each element of the list?
reduce(.f = merge) |>
# I needed to set the ticker symbol to the name of the columns. I found this nifty way of doing it since colnames(x=prices) <- value didn't work and I don't know why. Apparently this is prefix form. (Ex. AAPL.Adjusted is now AAPL)
`colnames<-` (value=symbols)
prices
# Keep only the last adjusted price of each month because we are focused on a long-term investment horizon, plus daily price flucuations cause too much noise can make it harder to identify long term trends.
# to.monthly() function is apart of xts library and is used to convert daily price data to monthly. We have set the adjusted close price to the last of each month, dropped the time, and set OHLC = False which means no "OPEN, HIGH, LOW, CLOSE" values.
monthly_adjusted_returns <- to.monthly(
x = prices,
drop.time = TRUE,
indexAt = 'lastof',
OHLC = FALSE
) |>
#We calculating simple returns  with the return.calculate function from PerformanceAnalytics library
Return.calculate(method = 'discrete') |>
na.omit()
monthly_adjusted_returns
#Creates a portfolio object using portfolio.spec function, which is a function from of PortfolioAnalytics
# returns a list.
Minimum_Variance_Portfolio <- portfolio.spec(assets = symbols)
Minimum_Variance_Portfolio
# Add Full Investment Constraint (weight sum constraint - weights must sum to 1 - prevents overleveraging and ensures diversification)
Minimum_Variance_Portfolio <- add.constraint(
portfolio = Minimum_Variance_Portfolio,
type = 'full_investment'
)
Minimum_Variance_Portfolio
# Add Box Constraint(weights have minimum and maximum values - limits the range of weights in the portfolio. Limits over/under leveraging for assets. Promotes diversification)
Minimum_Variance_Portfolio <- add.constraint(
portfolio = Minimum_Variance_Portfolio,
type = 'box',
min = 0.1,
max = .6
)
Minimum_Variance_Portfolio
# Add Objective to minimize risk (we are creating a minimization portfolio)
Minimum_Variance_Portfolio <- add.objective(
portfolio = Minimum_Variance_Portfolio,
type = 'risk',
name = 'var'
)
Minimum_Variance_Portfolio
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
#Creates a portfolio object using portfolio.spec function, which is a function from of PortfolioAnalytics
# returns a list.
maximum_expected_return_portfolio <- portfolio.spec(
assets = symbols
)
maximum_expected_return_portfolio
# Add weight_sum Constraint (weight sum constraint)
maximum_expected_return_portfolio <- add.constraint(
portfolio = maximum_expected_return_portfolio,
# similar to full_investment, expect you can modify the parameters for 'min_sum' and 'max_sum' to ease up constraints for calculating maximal returns
type = 'weight_sum',
min_sum = 0.99,
max_sum = 1.01,
enabled = TRUE
)
maximum_expected_return_portfolio
# Adding box constraint
maximum_expected_return_portfolio <- add.constraint(
portfolio = maximum_expected_return_portfolio,
type = 'box',
min = 0.05,
max = 0.6
)
maximum_expected_return_portfolio
# Add objective function - we are implementing a linear function to calculate the maximal expected returns
maximum_expected_return_portfolio <- add.objective(
portfolio = maximum_expected_return_portfolio,
type = 'return',
# name of function used to calculate the returns (we're just naming the type = 'return' parameter.:
name = 'mean'
)
maximum_expected_return_portfolio
# Optimize the portfolio
main_expected_return_portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = maximum_expected_return_portfolio,
# used for linear functions with linear constraints
optimize_method = "Rglpk",
trace = TRUE
)
main_expected_return_portfolio
class(main_expected_return_portfolio$objective_measures$mean)
#average annual return you can expect to earn.
(1+main_expected_return_portfolio$objective_measures$mean)^12-1
#Aggregating returns for the minimal variance portfolio
weights <- pluck(main_expected_return_portfolio,
'weights',
)
tibble(weights, symbols)
#check for sum_constaint
tibble(weights, symbols) |>
summarize(total_weight = sum(weights))
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'Quadprog',
trace = TRUE
)
Main_Variance_Portfolio
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'quadprog',
trace = TRUE
)
Main_Variance_Portfolio
# install.packages("ROI")
# install.packages("ROI.plugin.quadprog")
#install.packages("Rglpk")
# install.packages("ROI.plugin.glpk")
library(Rglpk)
library(glpk)
install.packages("ROI")
install.packages("ROI.plugin.quadprog")
install.packages("Rglpk")
Main_Variance_Portfolio <- optimize.portfolio(
R = monthly_adjusted_returns,
portfolio = Minimum_Variance_Portfolio,
optimize_method = 'Quadprog',
trace = TRUE
)
install.packages("ROI")
install.packages("ROI.plugin.quadprog")
